
/*Instrucciones a tener en cuenta:
 * Instrucciones:

Introducción al Estudio de Caso:
Presentar un escenario donde se necesita gestionar una colección jerárquica de datos, como la estructura de una empresa o la organización de un archivo de directorios.
Investigar y revisar los conceptos básicos de árboles binarios, incluyendo sus propiedades y operaciones fundamentales (inserción, eliminación, recorrido, búsqueda).
Implementación en Java:
Implementar una clase BinaryTree en Java, que incluya métodos para insertar, eliminar y recorrer los nodos del árbol.
Método de Búsqueda: Implementar un método search(int value) que devuelva true si el valor se encuentra en el árbol y false en caso contrario.
Método de Eliminación: Implementar un método delete(int value) para eliminar un nodo del árbol, ajustando las referencias de los nodos hijos según corresponda.
Recorrido Preorden: Implementar un método preOrderTraversal() que imprima los valores de los nodos en orden de preorden.
Recorrido Postorden: Implementar un método postOrderTraversal() que imprima los valores de los nodos en orden de postorden.
Encontrar el Máximo: Implementar un método findMax() que devuelva el valor máximo del árbol.
Altura del Árbol: Implementar un método height() que calcule la altura del árbol.
Contar Nodos: Implementar un método countNodes() que devuelva el número total de nodos en el árbol.
Comprobar si es un Árbol Binario de Búsqueda: Implementar un método isBST() que verifique si el árbol es un árbol binario de búsqueda válido.
Recorrido por Niveles: Implementar un método levelOrderTraversal() que imprima los valores de los nodos por niveles.
Crear un Árbol a partir de un Array: Implementar un método que construya un árbol binario de búsqueda a partir de un array de valores enteros.
Encontrar la Suma de Todos los Nodos: Implementar un método sumOfNodes() que calcule la suma de todos los valores en el árbol.
Contar Hojas: Implementar un método countLeaves() que devuelva el número de hojas en el árbol.
Buscar el Ancestro Común Más Cercano: Implementar un método lowestCommonAncestor(int value1, int value2) que encuentre el ancestro común más cercano de dos nodos dados.
Verificar el Balance del Árbol: Implementar un método isBalanced() que verifique si el árbol está balanceado.
Clonar el Árbol: Implementar un método cloneTree() que cree una copia exacta del árbol binario.
Mediante un conjunto de datos deben probar su implementación.
Aplicación Práctica:
Implementar un caso práctico donde utilicen su clase BinaryTree. Por ejemplo, la creación de un sistema de gestión de empleados donde cada nodo representa un empleado con sus datos asociados.
Presentación y Discusión:
Cada grupo o estudiante debe preparar una presentación sobre su implementación y el caso práctico que desarrollaron.
Se fomentará la discusión en clase sobre las diferentes aproximaciones y soluciones presentadas.
Evaluación:

(3 puntos) Correcta implementación de la clase y los métodos BinaryTree. Usar templates.
(3 Aplicación) Correcta implementación de la aplicación práctica con los métodos respectivos del BinaryTree. , con uso del dataset.
(7 puntos) Evaluación del pensamiento crítico aplicado el desarrollo del proyecto mediante la explicación del algoritmo.
(7 puntos) Modificación del código y/o pseudo código adecuado a un escenario específico.
 */

public class BinaryTree {
    //Cada linea comentada. 
    Node root; //Se crea un nodo raiz
    
    
    

}
